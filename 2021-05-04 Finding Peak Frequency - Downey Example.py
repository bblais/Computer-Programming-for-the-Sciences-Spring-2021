#!/usr/bin/env python
# coding: utf-8

# https://nbviewer.jupyter.org/gist/AllenDowney/01954327864c0657575cd0f74206234e

# In[1]:


get_ipython().run_line_magic('pylab', 'inline')
from science import *


# In[2]:


s = "55 56 56 56 56 57 57 57 56 57 59 57 59 58 59 59 59 59 59 59 59 60 61 60 60 61 61 61 62 62 62 62 61 61 61 61 62 62 63 63 62 63 62 63 63 63 64 63 63 63 63 62 62 61 60 58 59 58 58 57 58 57 56 56 56 56 56 55 55 55 55 54 54 55 56 56 56 57 56 57 57 57 58 57 58 59 57 59 59 59 58 60 59 60 60 59 60 61 60 60 61 61 61 61 61 61 61 62 62 63 62 63 63 63 63 62 63 63 63 63 63 63 63 64 63 63 63 63 62 61 60 60 58 59 59 58 58 58 57 56 56 56 55 55 56 55 55 54 55 55 54 55 55 55 56 56 56 57 57 57 57 57 58 57 60 58 58 59 58 60 60 60 60 60 60 61 61 61 62 61 62 61 62 62 62 62 62 62 61 62 64 63 62 62 63 63 63 63 64 63 62 63 64 64 63 64 64 63 65 63 64 62 62 60 60 59 59 57 57 57 56 55 55 55 55 55 54 55 54 54 54 54 55 55 57 56 57 56 56 58 58 59 58 58 58 58 58 58 59 59 60 60 60 60 60 61 60 61 61 60 61 62 61 62 62 61 62 61 62 62 62 61 62 63 63 63 63 64 63 63 63 63 64 63 64 64 63 62 61 60 61 59 60 58 57 57 56 56 57 55 56 55 55 55 55 55 55 56 56 56 56 56 57 57 58 58 59 59 58 59 60 60 60 59 60 59 60 60 60 60 61 62 61 61 62 61 61 62 62 63 61 62 63 63 62 63 64 63 63 63 62 61 61 60 60 60 58 58 57 57 57 56 57 56 56 56 55 56 56 57 58 57 58 57 57 59 59 58 59 59 60 59 60 59 60 59 61 61 60 61 61 61 61 62 61 62 62 62 62 62 62 63 62 63 61 63 63 62 63 63 64 63 64 64 65 63 65 63 65 63 63 63 61 60 59 60 59 58 57 57 56 56 56 55 55 55 56 56 56 56 58 57 57 58 58 57 58 58 60 59 59 60 60 61 61 60 61 60 61 61 61 61 61 62 62 62 62 63 62 62 63 62 62 61 63 63 64 64 64 63 64 63 64 64 64 62 62 61 61 60 59 59 58 58 58 56 56 56 56 55 56 55 55 54 55 55 56 55 57 57 58 58 58 57 59 58 58 58 58 59 59 61 60 59 60 60 60 59 60 60 60 61 62 61 61 62 62 62 63 62 62 62 62 63 63 63 63 62 63 63 64 63 64 64 64 64 63 64 63 63 65 64 63 63 63 62 63 60 61 60 60 59 59 57 58 58 58 56 56 56 55 55 55 55 55 56 56 55 55 56 57 57 58 57 58 59 58 58 59 60 59 59 60 60 61 60 60 61 60 60 61 61 62 60 61 61 62 63 62 62 62 62 63 62 63 63 64 63 64 64 63 63 63 63 63 64 64 64 63 64 63 63 61 60 60 59 58 58 58 58 57 56 56 55 56 55 55 55 55 55 55 55 55 55 55 56 55 56 58 57 58 58 59 57 57 58 59 58 59 59 59 60 60 60 61 61 60 60 61 62 61 61 61 62 61 62 62 62 62 63 62 63 63 62 63 63 62 62 64 64 64 64 64 65 63 65 64 63 62 61 61 60 60 59 58 58 58 57 57 56 55 56 56 55 54 55 55 54 55 56 57 55 56 57 58 57 57 58 59 57 58 58 59 59 60 60 60 60 60 60 60 61 61 61 61 61 61 60 62 62 62 62 62 63 62 62 63 62 63 63 63 63 63 63 63 64 64 63 63 64 64 64 63 64 64 63 62 61 61 60 59 59 59 59 58 58 58 57 57 57 56 56 56 55 55 54 55 54 55 54 55 56 56 55 57 56 57 57 57 57 58 59 58 58 59 58 59 59 59 59 61 60 60 61 61 60 60 60 60 60 61 63 61 62 63 63 62 63 62 62 62 62 63 63 63 62 64 63 64 63 64 63 64 64 62 62 60 59 60 59 58 57 57 57 57 56 55 56 56 55 55 55 55 55 55 55 55 56 55 57 57 56 58 57 58 58 59 59 60 59 58 60 60 60 60 59 60 60 60 60 60 61 61 61 61 61 61 62 61 62 63 63 62 61 62 63 63 63 63 63 64 64 64 64 63 64 63 63 64 63 64 64 64 63 64 61 60 61 61 59 59 59 59 58 57 57 57 57 55 57 56 55 55 55"
t = s.split()
len(t)


# In[3]:


ys = np.array(t, dtype=float)
ts = np.arange(0, len(ys)) * 2


# In[4]:


plot(ts, ys)
xlabel('Time (s)')
ylabel('Temperature (C)');


# In[5]:


def brute_force_single_freq_p(t,d,f):

    def G1(t,w):
        return cos(w*t)
    def G2(t,w):
        return sin(w*t)


    m=2
    N=len(d)
    
    omega=2*pi*f
    d=d-mean(d)  # take out the DC
    
    G=matrix("0.0;0.0")
    gs=[]
    for w in omega:
        g=matrix("0.0 0.0 ; 0 0")
        
        for l in t:
            g+=matrix([ [G1(l,w)*G1(l,w), G1(l,w)*G2(l,w)],
                        [G2(l,w)*G1(l,w), G2(l,w)*G2(l,w)] ])   # eq 3.4
                        
        gs.append(g)
        
    
    c=N/2.0 + sin(N*omega)/(2*sin(omega))  # around eq 6.1
    s=N/2.0 - sin(N*omega)/(2*sin(omega))
    
    _lambda,V=eig(gs[1])  # right before 3.5
    e=V.T  # each row of "e" is an eigenvector
    
    
    Hs=[]
    for w in omega:
        H=[0]*m
        G=[G1,G2]
        
        for j in range(m):
            for k in range(m):
                H[j]+=1/sqrt(_lambda[j])*e[j,k]*G[k](t,w)  # eq 3.5
                
        Hs.append(H)
        
    
    hs=[]
    h=[[] for _ in range(m)]
    for w,H in zip(omega,Hs):
        for j in range(m):
            val=sum(d*H[j])      # eq 3.13
            h[j].append(val)
    
    for j in range(m):
        h[j]=array(h[j])
        
    hb2=0
    db2=0
    for j in range(m):
        hb2+=h[j]**2       # eq 3.15
    hb2/=m
    db2+=sum(d**2)/len(d)       # eq 3.17
    
    
    p=(1-m*hb2/(N*db2))**((m-N)/2.0)    # eq 3.17
    
    return p    


# In[6]:


T=linspace(2,500,1000)
f=1/T
    
get_ipython().run_line_magic('time', 'p=brute_force_single_freq_p(ts,ys,f)')


# In[7]:


figure(figsize=(12,9))
subplot(2,1,1)
plot(T,p,'.-')    
ylabel('amplitude')
ax=gca()
ax.set_yscale('log')
grid(True)
gca().set_xlim([min(T),max(T)])

subplot(2,1,2)
plot(T,p,'.-')
xlabel('period of oscillation')
ylabel('amplitude')
grid(True)
gca().set_xlim([min(T),max(T)])


# In[8]:


idx=argmax(p)
T[idx]


# In[9]:


A2,A1,A0=polyfit(T[idx-5:idx+5],p[idx-5:idx+5],2)
sigma=sqrt(-1/(2*A2));
mu=A1*sigma**2;
#A=exp(A0+mu**2/(2*sigma**2));


# In[10]:


sigma


# In[13]:


T2=T[ (T>158) & (T<200)]
p2=p[ (T>158) & (T<200)]
plot(T2,p2)
ax=gca()
ax.set_yscale('log')
grid(True)


# In[14]:


idx2=argmax(p2)
T2[idx2]


# In[ ]:




